var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AutoUpdater_checker;
import { EventEmitter } from 'node:events';
import { cleanupHotDownloadDir, downloadDatabases, verifyChecksums } from './download-helpers.js';
import { GeoIpDbName } from './primitives.js';
const updateTimer = 2 * 24 * 60 * 60 * 1000; // 48 hours in ms
export class AutoUpdater extends EventEmitter {
    constructor(dbList, customStorageDir) {
        super();
        Object.defineProperty(this, "dbList", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                GeoIpDbName.ASN,
                GeoIpDbName.Country,
                GeoIpDbName.City
            ]
        });
        Object.defineProperty(this, "customStorageDir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "checkingForUpdates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "downloading", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        _AutoUpdater_checker.set(this, void 0);
        if (dbList)
            this.dbList = dbList;
        if (customStorageDir)
            this.customStorageDir = customStorageDir;
        cleanupHotDownloadDir(this.customStorageDir);
        __classPrivateFieldSet(this, _AutoUpdater_checker, setInterval(this.checkForUpdates.bind(this), updateTimer), "f");
        // Schedule first update check
        setTimeout(this.checkForUpdates.bind(this), 500);
        return this;
    }
    async checkForUpdates(secondRun = false) {
        if (this.checkingForUpdates)
            return;
        this.checkingForUpdates = true;
        try {
            const paths = await verifyChecksums(this.dbList, this.customStorageDir);
            this.emit('check-ok', paths);
        }
        catch (err) {
            if (secondRun)
                throw err;
            if (!err.message.startsWith('Checksum mismatch') && !(err.code === 'ENOENT'))
                throw err;
            this.update();
        }
        finally {
            this.checkingForUpdates = false;
        }
    }
    async update() {
        if (this.downloading)
            return;
        this.downloading = true;
        try {
            const paths = await downloadDatabases(this.dbList, this.customStorageDir);
            await this.checkForUpdates(true);
            this.emit('updated', paths);
        }
        catch (err) {
            console.error(err);
            console.warn('Warning: allowing the GeoLite databases to self-update is mandatory to comply with license requirements.');
        }
        finally {
            cleanupHotDownloadDir(this.customStorageDir);
            this.downloading = false;
        }
    }
    close() {
        clearInterval(__classPrivateFieldGet(this, _AutoUpdater_checker, "f"));
        super.removeAllListeners();
    }
}
_AutoUpdater_checker = new WeakMap();
